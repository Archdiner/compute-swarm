"""
ComputeSwarm Seller Agent
Queue-based Seller Agent with Local Dashboard and One-Click Start
"""

import asyncio
import sys
import signal
import os
import json
from typing import Optional, List
from datetime import datetime
from decimal import Decimal
import httpx
import structlog
from fastapi import FastAPI, HTTPException, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
from uvicorn import Config, Server
from eth_account import Account
from pathlib import Path

from src.execution.gpu_detector import GPUDetector
from src.marketplace.models import NodeRegistration, GPUType
from src.config import get_seller_config
from src.execution import JobExecutor
from src.payments import PaymentProcessor, calculate_job_cost, calculate_estimated_cost

# Global Log Queue for Broadcasting
log_queue = asyncio.Queue()

def queue_log_processor(logger, method_name, event_dict):
    """Push log event to the async queue for broadcasting"""
    try:
        # Create a copy to avoid mutation issues
        log_entry = event_dict.copy()
        log_entry["timestamp"] = datetime.now().isoformat()
        log_entry["level"] = method_name.upper()
        
        # We can't await here (processors are sync), so we put_nowait
        # If queue is full or no loop, we ignore (essential for startup safety)
        try:
            log_queue.put_nowait(log_entry)
        except:
            pass
    except:
        pass
    return event_dict

logger = structlog.get_logger()

# Dashboard Path
DASHBOARD_DIR = Path(__file__).parent / "dashboard"

class ConnectionManager:
    """Manages WebSocket connections for log streaming"""
    def __init__(self):
        self.active_connections: List[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        if websocket in self.active_connections:
            self.active_connections.remove(websocket)

    async def broadcast(self, message: dict):
        # Broadcast to all connected clients
        # Handle disconnections gracefully
        disconnected = []
        for connection in self.active_connections:
            try:
                await connection.send_json(message)
            except:
                disconnected.append(connection)
        
        for conn in disconnected:
            self.disconnect(conn)

manager = ConnectionManager()

class SellerAgent:
    """
    Queue-based Seller Agent that:
    1. Detects local GPU hardware
    2. Registers with the marketplace
    3. Polls job queue for matching jobs
    4. Claims jobs atomically
    5. Executes jobs with safety controls
    6. Processes payments and reports results
    7. Tracks and displays earnings
    8. Serves a local web dashboard with live logs
    """

    def __init__(self):
        self.config = get_seller_config()
        self.node_id: Optional[str] = None
        self.gpu_info = None
        self.price_per_hour: Optional[Decimal] = None
        self.running = False
        self.agent_loop_running = False  # Controlled by Start/Stop button
        self.is_busy = False
        self.client = httpx.AsyncClient(timeout=30.0)
        
        # Earnings tracking (session-only)
        self.session_earnings = Decimal("0")
        self.session_jobs_completed = 0
        self.session_jobs_failed = 0
        self.session_start_time: Optional[datetime] = None
        self.generated_wallet = False
        
        # Components
        self.executor: Optional[JobExecutor] = None
        self.payment_processor: Optional[PaymentProcessor] = None
        
        # Web Server
        self.app = FastAPI()
        self.setup_routes()

    def check_or_create_wallet(self):
        """
        One-Click Start: Checks if a wallet exists in env or config.
        If not, generates a new one and SAVES it to .env.local
        """
        if self.config.seller_private_key:
            return  # Already has a key

        print("\n" + "!" * 60)
        print("NO WALLET FOUND! One-Click Start Mode initiated.")
        print("Generating a new Ethereum wallet for you...")
        
        # Generate new account
        acct = Account.create()
        private_key = acct.key.hex()
        address = acct.address
        
        # Update runtime config
        self.config.seller_private_key = private_key
        self.config.seller_address = address
        self.generated_wallet = True

        # Save to .env.local
        env_path = Path(".env.local")
        mode = "a" if env_path.exists() else "w"
        
        try:
            with open(env_path, mode) as f:
                f.write(f"\n# Auto-generated by ComputeSwarm One-Click Start on {datetime.now()}\n")
                f.write(f"SELLER_PRIVATE_KEY={private_key}\n")
                f.write(f"SELLER_ADDRESS={address}\n")
            
            print(f"âœ“ Wallet created: {address}")
            print(f"âœ“ Private Key saved to: {env_path.absolute()}")
            print("KEEP THIS SAFE! This is your only way to access earnings.")
            print("!" * 60 + "\n")
            
        except Exception as e:
            logger.error("failed_to_save_wallet", error=str(e))
            print("CRITICAL ERROR: Could not save generated wallet to file.")
            print(f"Private Key: {private_key}")
            print("WRITE THIS DOWN NOW OR YOU WILL LOSE ACCESS.")

    def setup_routes(self):
        """Configure FastAPI routes for the local dashboard"""
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_methods=["*"],
            allow_headers=["*"],
        )

        @self.app.get("/")
        async def serve_dashboard():
            if (DASHBOARD_DIR / "index.html").exists():
                return FileResponse(DASHBOARD_DIR / "index.html")
            return {"error": "Dashboard UI not found"}

        @self.app.websocket("/ws/logs")
        async def websocket_endpoint(websocket: WebSocket):
            await manager.connect(websocket)
            try:
                while True:
                    # Keep connection open, wait for client disconnect
                    await websocket.receive_text()
            except WebSocketDisconnect:
                manager.disconnect(websocket)

        @self.app.get("/api/status")
        async def get_status():
            uptime = "00:00:00"
            if self.session_start_time and self.running:
                delta = datetime.now() - self.session_start_time
                hours, remainder = divmod(int(delta.total_seconds()), 3600)
                minutes, seconds = divmod(remainder, 60)
                uptime = f"{hours}h {minutes}m {seconds}s"

            return {
                "running": self.agent_loop_running,
                "is_busy": self.is_busy,
                "node_id": self.node_id,
                "wallet_address": self.config.seller_address,
                "generated_wallet": self.generated_wallet,
                "gpu": {
                    "name": self.gpu_info.device_name if self.gpu_info else "Unknown",
                    "vram": str(self.gpu_info.vram_gb) if self.gpu_info and self.gpu_info.vram_gb else "0",
                } if self.gpu_info else None,
                "earnings": str(self.session_earnings),
                "jobs_completed": self.session_jobs_completed,
                "jobs_failed": self.session_jobs_failed,
                "price_per_hour": str(self.price_per_hour) if self.price_per_hour else "0.00",
                "uptime": uptime
            }

        @self.app.post("/api/control/start")
        async def start_node():
            if self.agent_loop_running:
                return {"message": "Already running"}
            
            self.agent_loop_running = True
            logger.info("agent_resumed_by_user")
            return {"message": "Node started"}

        @self.app.post("/api/control/stop")
        async def stop_node():
            if not self.agent_loop_running:
                return {"message": "Already stopped"}
            
            self.agent_loop_running = False
            logger.info("agent_paused_by_user")
            
            # Send unavailable status
            if self.node_id:
                try:
                    await self.client.post(
                        f"{self.config.marketplace_url}/api/v1/nodes/{self.node_id}/unavailable"
                    )
                except:
                    pass
            return {"message": "Node stopped"}

    async def initialize(self):
        """Initialize resources and start the agent"""
        self.check_or_create_wallet()
        
        if self.config.seller_private_key:
            self.payment_processor = PaymentProcessor(
                private_key=self.config.seller_private_key,
                rpc_url=self.config.rpc_url,
                usdc_address=self.config.usdc_contract_address,
                network=self.config.network,
                testnet_mode=self.config.testnet_mode,
            )
            # Avoid logging sensitive info, but here address is fine
            # logger.info("payment_processor_ready") 

        logger.info("seller_agent_initializing", seller=self.config.seller_address)

        self.gpu_info = GPUDetector.detect_gpu()
        logger.info(
            "gpu_detected",
            gpu_type=self.gpu_info.gpu_type.value,
            device_name=self.gpu_info.device_name,
            vram_gb=float(self.gpu_info.vram_gb) if self.gpu_info.vram_gb else None
        )

        if not GPUDetector.test_gpu():
            logger.error("gpu_test_failed", message="GPU is not functioning properly")
            sys.exit(1)

        if self.gpu_info.gpu_type.value == "cuda":
            self.price_per_hour = Decimal(str(self.config.default_price_per_hour_cuda))
        elif self.gpu_info.gpu_type.value == "mps":
            self.price_per_hour = Decimal(str(self.config.default_price_per_hour_mps))
        else:
            self.price_per_hour = Decimal("0.10")

        model_cache_path = Path(self.config.model_cache_dir).expanduser()
        
        self.executor = JobExecutor(
            docker_enabled=self.config.docker_enabled,
            docker_image=self.config.docker_image,
            docker_image_gpu=self.config.docker_image_gpu,
            docker_memory_limit=self.config.docker_memory_limit,
            docker_cpu_limit=self.config.docker_cpu_limit,
            docker_pids_limit=self.config.docker_pids_limit,
            docker_tmpfs_size=self.config.docker_tmpfs_size,
            model_cache_dir=model_cache_path if self.config.model_cache_enabled else None,
            gpu_type=self.gpu_info.gpu_type.value,
            docker_network_enabled=self.config.docker_network_enabled,
            docker_setup_timeout=self.config.docker_setup_timeout
        )
        
        # logger.info("executor_initialized")

        await self._check_docker_setup()
        await self.register()

        self.running = True
        self.agent_loop_running = True
        self.session_start_time = datetime.now()
        
        # Start Background Loops
        asyncio.create_task(self.heartbeat_loop())
        asyncio.create_task(self.job_polling_loop())
        asyncio.create_task(self.earnings_display_loop())
        asyncio.create_task(self.broadcast_logs_loop())  # Start log broadcasting

        self._display_status()
        print(f"\nðŸš€ DASHBOARD AVAILABLE AT: http://localhost:8001")

    async def broadcast_logs_loop(self):
        """Worker to pop logs from queue and broadcast via WebSocket"""
        while self.running:
            try:
                log_entry = await log_queue.get()
                await manager.broadcast(log_entry)
                log_queue.task_done()
            except asyncio.CancelledError:
                break
            except Exception:
                pass

    async def _check_docker_setup(self):
        if not self.config.docker_enabled:
            logger.warning("docker_disabled", message="Docker sandboxing is disabled.")
            return
        
        docker_available = await self.executor._check_docker_available()
        if not docker_available:
            logger.error("docker_not_available", message="Docker is not available.")
            sys.exit(1)
        
        if self.gpu_info.gpu_type.value == "cuda":
            image = self.config.docker_image_gpu
            image_type = "GPU"
        else:
            image = self.config.docker_image
            image_type = "CPU"
        
        image_exists = await self.executor._check_docker_image_exists(image)
        if not image_exists:
            logger.warning("docker_image_missing", image=image, message="Attempting to build...")
            if not await self._try_build_docker_image(image_type):
                logger.warning("docker_image_build_failed", image=image)
        else:
            logger.info("docker_image_ready", image=image)
        
        if self.gpu_info.gpu_type.value == "cuda":
            if not await self.executor._check_nvidia_docker_available():
                logger.warning("nvidia_docker_unavailable", message="GPU jobs will run on CPU.")

    async def _try_build_docker_image(self, image_type: str) -> bool:
        import subprocess
        project_root = Path(__file__).parent.parent.parent
        
        if image_type.lower() == "gpu":
            dockerfile = project_root / "Dockerfile.sandbox-gpu"
            tag = self.config.docker_image_gpu
        else:
            dockerfile = project_root / "Dockerfile.sandbox"
            tag = self.config.docker_image
        
        if not dockerfile.exists():
            return False
        
        logger.info("building_docker_image", tag=tag)
        print(f"\nBuilding {image_type} Docker image (this may take a few minutes)...")
        
        try:
            process = await asyncio.create_subprocess_exec(
                "docker", "build", "-t", tag, "-f", str(dockerfile), str(project_root),
                stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=600)
            return process.returncode == 0
        except Exception as e:
            logger.warning("docker_build_error", error=str(e))
            return False

    async def register(self):
        try:
            registration = NodeRegistration(
                seller_address=self.config.seller_address,
                gpu_info=self.gpu_info,
                price_per_hour=self.price_per_hour,
                endpoint=""
            )
            response = await self.client.post(
                f"{self.config.marketplace_url}/api/v1/nodes/register",
                json=registration.model_dump()
            )
            response.raise_for_status()
            self.node_id = response.json()["node_id"]
            logger.info("registered_with_marketplace", node_id=self.node_id)
        except Exception as e:
            logger.error("registration_failed", error=str(e))
            sys.exit(1)

    def _display_status(self):
        uptime = ""
        if self.session_start_time:
            delta = datetime.now() - self.session_start_time
            hours, remainder = divmod(int(delta.total_seconds()), 3600)
            minutes, seconds = divmod(remainder, 60)
            uptime = f"{hours}h {minutes}m {seconds}s"
        
        print("\n" + "=" * 60)
        print("  ComputeSwarm Seller Agent")
        print("=" * 60)
        print(f"  Node ID:      {self.node_id or 'Not registered'}")
        print(f"  Status:       {'Busy' if self.is_busy else ('Active' if self.agent_loop_running else 'Paused')}")
        print(f"  Session:      ${float(self.session_earnings):.4f} ({self.session_jobs_completed} jobs)")
        print(f"  Uptime:       {uptime}")
        print("=" * 60 + "\n")

    async def earnings_display_loop(self):
        while self.running:
            try:
                await asyncio.sleep(300)
                if self.agent_loop_running:
                     self._display_status()
            except asyncio.CancelledError:
                break
            except Exception:
                pass

    async def heartbeat_loop(self):
        while self.running:
            try:
                await asyncio.sleep(30)
                if not self.node_id: continue
                is_available = (not self.is_busy) and self.agent_loop_running
                await self.client.post(
                    f"{self.config.marketplace_url}/api/v1/nodes/{self.node_id}/heartbeat",
                    params={"available": is_available}
                )
            except Exception:
                pass

    async def job_polling_loop(self):
        while self.running:
            try:
                if self.agent_loop_running and not self.is_busy:
                    await self.try_claim_job()
                await asyncio.sleep(5)
            except Exception as e:
                logger.error("polling_error", error=str(e))
                await asyncio.sleep(10)

    async def try_claim_job(self):
        if not self.node_id: return
        try:
            response = await self.client.post(
                f"{self.config.marketplace_url}/api/v1/jobs/claim",
                params={
                    "node_id": self.node_id,
                    "seller_address": self.config.seller_address,
                    "gpu_type": self.gpu_info.gpu_type.value,
                    "price_per_hour": float(self.price_per_hour),
                    "vram_gb": float(self.gpu_info.vram_gb) if self.gpu_info.vram_gb else 0.0,
                    "num_gpus": self.gpu_info.num_gpus if hasattr(self.gpu_info, 'num_gpus') else 1
                }
            )
            response.raise_for_status()
            data = response.json()
            if data.get("claimed"):
                job_id = data["job_id"]
                logger.info("job_claimed", job_id=job_id)
                asyncio.create_task(self.execute_job(
                    job_id=job_id,
                    script=data["script"],
                    requirements=data.get("requirements"),
                    timeout_seconds=data["timeout_seconds"],
                    max_price_per_hour=Decimal(str(data["max_price_per_hour"])),
                    buyer_address=data.get("buyer_address", ""),
                    num_gpus=data.get("num_gpus", 1),
                    gpu_memory_limit_per_gpu=data.get("gpu_memory_limit_per_gpu")
                ))
        except Exception:
             pass

    async def execute_job(self, job_id, script, requirements, timeout_seconds, max_price_per_hour, buyer_address, num_gpus, gpu_memory_limit_per_gpu):
        self.is_busy = True
        try:
            if self.payment_processor and buyer_address:
                estimated_cost = calculate_estimated_cost(timeout_seconds, self.price_per_hour)
                try:
                    buyer_balance = self.payment_processor.get_usdc_balance(buyer_address)
                    if buyer_balance < estimated_cost:
                         await self.fail_job(job_id, f"Insufficient Buyer Balance: {buyer_balance}")
                         return
                except Exception:
                    pass

            await self.client.post(f"{self.config.marketplace_url}/api/v1/jobs/{job_id}/start")
            
            result = await self.executor.execute_job(
                job_id=job_id,
                script=script,
                requirements=requirements,
                timeout_seconds=timeout_seconds,
                num_gpus=num_gpus,
                gpu_memory_limit_per_gpu=gpu_memory_limit_per_gpu,
                buyer_address=buyer_address
            )

            cost_usd, cost_usdc_wei = calculate_job_cost(
                result.execution_time, self.price_per_hour
            )

            if hasattr(result, 'metrics_collector') and result.metrics_collector:
                try:
                    from src.database import get_db_client
                    db = get_db_client()
                    await db.save_job_metrics(job_id=job_id, metrics=result.metrics_collector.metrics)
                except:
                    pass

            if result.success:
                await self.complete_job(job_id, result.output, result.exit_code, result.execution_time, cost_usd, cost_usdc_wei, buyer_address)
            else:
                await self.fail_job(job_id, result.error, result.exit_code, result.execution_time)

        except Exception as e:
            logger.error("execution_error", error=str(e))
            await self.fail_job(job_id, f"Internal Error: {str(e)}")
        finally:
            self.is_busy = False

    async def complete_job(self, job_id, output, exit_code, duration, cost, cost_wei, buyer):
        payment_tx = None
        if self.payment_processor and buyer and cost_wei > 0:
            try:
                receipt = await self.payment_processor.settle_payment(buyer, cost_wei, job_id)
                if receipt.success:
                    payment_tx = receipt.tx_hash
                    logger.info("payment_settled", tx=payment_tx)
            except Exception as e:
                logger.error("payment_failed", error=str(e))

        try:
            await self.client.post(
                f"{self.config.marketplace_url}/api/v1/jobs/{job_id}/complete",
                params={
                    "job_id": job_id,
                    "output": output,
                    "exit_code": exit_code,
                    "execution_duration": float(duration),
                    "total_cost": float(cost),
                    "payment_tx_hash": payment_tx
                }
            )
            self.session_earnings += cost
            self.session_jobs_completed += 1
            logger.info("job_completed", job_id=job_id, earned=float(cost))
        except Exception:
            pass

    async def fail_job(self, job_id, error, exit_code=None, duration=None):
        try:
            params = {"job_id": job_id, "error": error}
            if exit_code is not None: params["exit_code"] = exit_code
            if duration is not None: params["execution_duration"] = float(duration)
            await self.client.post(f"{self.config.marketplace_url}/api/v1/jobs/{job_id}/fail", params=params)
            self.session_jobs_failed += 1
            print(f"\nâœ— Job {job_id[:12]}... failed")
        except Exception:
            pass

    async def stop(self):
        logger.info("stopping_agent")
        self.running = False
        if self.node_id:
            try:
                await self.client.post(f"{self.config.marketplace_url}/api/v1/nodes/{self.node_id}/unavailable")
            except:
                pass
        await self.client.aclose()


async def main():
    structlog.configure(
        processors=[
            structlog.processors.TimeStamper(fmt="iso"),
            structlog.processors.add_log_level,
            queue_log_processor,
            structlog.dev.ConsoleRenderer()
        ]
    )

    agent = SellerAgent()
    await agent.initialize()

    loop = asyncio.get_running_loop()
    stop_signal = asyncio.Event()
    
    def signal_handler():
        logger.info("shutdown_signal_received")
        stop_signal.set()

    for sig in (signal.SIGINT, signal.SIGTERM):
        loop.add_signal_handler(sig, signal_handler)

    port = int(os.getenv("SELLER_PORT", "8001"))
    config = Config(app=agent.app, host="0.0.0.0", port=port, log_level="warning")
    server = Server(config)
    server_task = asyncio.create_task(server.serve())
    
    try:
        await stop_signal.wait()
    finally:
        await agent.stop()
        server.should_exit = True
        await server_task

if __name__ == "__main__":
    asyncio.run(main())
